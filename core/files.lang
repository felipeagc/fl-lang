module files

version "posix" {
    import "core:posix"
    import "core:c"
    import "core:strings"

    pub func get_cwd_alloc() -> string {
        var buf = posix.getcwd(null, 0);
        return buf[0:c.strlen(buf)];
    }

    pub func chdir(path: string) -> bool {
        var c_path = strings.to_c_str_alloc(path);
        defer dealloc(c_path);
        return posix.chdir(c_path) == 0;
    }

    pub func dir_entries_alloc(path: string) -> []string {
        var c_path = strings.to_c_str_alloc(path);
        defer dealloc(c_path);

        var entries: [dyn]string;

        var ep: *posix.dirent;
        var dp: *posix.DIR = posix.opendir(c_path);

        if (dp != null) {
            ep = posix.readdir(dp);
            while (ep) {
                var c_entry = c.strdup(ep.d_name.ptr);
                append(&entries, c_entry[0:c.strlen(c_entry)]);
                ep = posix.readdir(dp);
            }

            posix.closedir(dp);
        }

        return entries[:];
    }
}

version "win32" {
    import "core:win32"
    import "core:c"
    import "core:strings"

    pub func get_cwd_alloc() -> string {
        var required_size = win32.GetCurrentDirectory(0, null);
        var buf: *win32.TCHAR = alloc(size_of(win32.TCHAR) * cast(uint)required_size);
        defer dealloc(buf);
        win32.GetCurrentDirectory(required_size, buf);
        return win32.wstr_to_string_alloc(buf, required_size);
    }

    pub func chdir(path: string) -> bool {
        var wpath = win32.to_cwstr_alloc(path);
        defer dealloc(wpath);
        return win32.SetCurrentDirectory(wpath) != 0;
    }

    pub func dir_entries_alloc(path: string) -> []string {
        var search_str = strings.concat_alloc(path, "\\*");
        defer delete(&search_str);
        var c_path = strings.to_c_str_alloc(search_str);
        defer dealloc(c_path);

        var data: win32.WIN32_FIND_DATAA;
        var first_file = win32.FindFirstFileA(c_path, &data);
        defer win32.FindClose(first_file);

        var entries: [dyn]string;
        var entry = make(string, c.strlen(data.cFileName.ptr));
        c.memcpy(entry.ptr, data.cFileName, entry.len);
        append(&entries, entry);
        while (win32.FindNextFileA(first_file, &data) != false) {
            var entry = make(string, c.strlen(data.cFileName.ptr));
            c.memcpy(entry.ptr, data.cFileName, entry.len);
            append(&entries, entry);
        }

        return entries[:];
    }
}

pub func dir_entries_free(entries: []string) {
    for (*entry in entries) {
        dealloc(entry.*.ptr);
    }
    dealloc(entries.ptr);
}

