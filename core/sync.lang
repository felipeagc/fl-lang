module sync

pub typedef ThreadStart func* (arg: *void) -> *void;

version "posix" {
    import "core:posix"
    pub typedef Thread posix.pthread_t;
    pub typedef Mutex posix.pthread_mutex_t;
    pub typedef Cond posix.pthread_cond_t;
}

//
// Threads
//

version "posix" {
    #[inline]
    pub func thread_create(start: ThreadStart, arg: *void) -> Thread {
        var thread: Thread;
        posix.pthread_create(&thread, null, start, arg);
        return thread;
    }

    #[inline]
    pub func thread_wait(thread: Thread) {
        posix.pthread_join(thread, null);
    }

    #[inline]
    pub func thread_sleep(milliseconds: u32) {
        posix.usleep(1000 * milliseconds);
    }

    #[inline]
    pub func thread_detach(thread: Thread) {
        posix.pthread_detach(thread);
    }

    #[inline]
    pub func thread_exit() {
        posix.pthread_exit(cast(*void)0);
    }
}

//
// Mutex
//

version "posix" {
    #[inline]
    pub func mutex_init(mtx: *Mutex) {
        posix.pthread_mutex_init(mtx, null);
    }

    #[inline]
    pub func mutex_destroy(mtx: *Mutex) {
        posix.pthread_mutex_destroy(mtx);
    }

    #[inline]
    pub func mutex_lock(mtx: *Mutex) {
        posix.pthread_mutex_lock(mtx);
    }

    #[inline]
    pub func mutex_trylock(mtx: *Mutex) {
        posix.pthread_mutex_trylock(mtx);
    }

    #[inline]
    pub func mutex_unlock(mtx: *Mutex) {
        posix.pthread_mutex_unlock(mtx);
    }
}

//
// Condition variable
//

version "posix" {
    #[inline]
    pub func cond_init(cond: *Cond) {
        posix.pthread_cond_init(cond, null);
    }

    #[inline]
    pub func cond_destroy(cond: *Cond) {
        posix.pthread_cond_destroy(cond);
    }

    #[inline]
    pub func cond_wake_one(cond: *Cond) {
        posix.pthread_cond_signal(cond);
    }

    #[inline]
    pub func cond_wake_all(cond: *Cond) {
        posix.pthread_cond_broadcast(cond);
    }

    #[inline]
    pub func cond_wait(cond: *Cond, mtx: *Mutex) {
        posix.pthread_cond_wait(cond, mtx);
    }
}

//
// win32 implementation:
//


version "win32" {
    import "core:win32"
    pub typedef Thread win32.HANDLE;
    pub typedef Mutex win32.CRITICAL_SECTION;
    pub typedef Cond win32.CONDITION_VARIABLE;
}

version "win32" {
    typedef Bundle struct {
        start: ThreadStart,
        arg: *void,
    };

    extern func "std" thread_start_wrapper(arg: win32.LPVOID) -> win32.DWORD {
        var bundle = cast(*Bundle)arg;
        var exit_code = bundle.start(bundle.arg);
        dealloc(bundle);
        return cast(win32.DWORD)exit_code;
    }

    #[inline]
    pub func thread_create(start: ThreadStart, arg: *void) -> Thread {
        var bundle = new(Bundle);
        bundle.start = start;
        bundle.arg = arg;
        var thread = win32.CreateThread(
            null, 0, thread_start_wrapper, cast(win32.LPVOID)bundle, 0, null);
        return thread;
    }

    #[inline]
    pub func thread_wait(thread: Thread) {
        if (win32.WaitForSingleObject(thread, win32.INFINITE) == win32.WAIT_FAILED) {
            return;
        }

        var dw_res: win32.DWORD;
        if (!win32.GetExitCodeThread(thread, &dw_res)) {
            return;
        }

        win32.CloseHandle(thread);
    }

    #[inline]
    pub func thread_sleep(milliseconds: u32) {
        win32.Sleep(cast(win32.DWORD)milliseconds);
    }

    #[inline]
    pub func thread_detach(thread: Thread) {
        win32.CloseHandle(thread);
    }

    #[inline]
    pub func thread_exit() {
        win32.ExitThread(0);
    }
}

version "win32" {
    #[inline]
    pub func mutex_init(mtx: *Mutex) {
        win32.InitializeCriticalSection(mtx);
    }

    #[inline]
    pub func mutex_destroy(mtx: *Mutex) {
        win32.DeleteCriticalSection(mtx);
    }

    #[inline]
    pub func mutex_lock(mtx: *Mutex) {
        win32.EnterCriticalSection(mtx);
    }

    #[inline]
    pub func mutex_trylock(mtx: *Mutex) {
        win32.TryEnterCriticalSection(mtx);
    }

    #[inline]
    pub func mutex_unlock(mtx: *Mutex) {
        win32.LeaveCriticalSection(mtx);
    }
}

version "win32" {
    #[inline]
    pub func cond_init(cond: *Cond) {
        win32.InitializeConditionVariable(cond);
    }

    #[inline]
    pub func cond_destroy(cond: *Cond) {
    }

    #[inline]
    pub func cond_wake_one(cond: *Cond) {
        win32.WakeConditionVariable(cond);
    }

    #[inline]
    pub func cond_wake_all(cond: *Cond) {
        win32.WakeAllConditionVariable(cond);
    }

    #[inline]
    pub func cond_wait(cond: *Cond, mtx: *Mutex) {
        win32.SleepConditionVariableCS(cond, mtx, win32.INFINITE);
    }
}

